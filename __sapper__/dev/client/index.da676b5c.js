import { S as SvelteComponentDev, i as init, s as safe_not_equal, l as create_slot, e as element, t as text, c as claim_element, b as children, d as claim_text, f as detach, h as add_location, g as attr, j as insert, k as append, o as get_slot_changes, p as get_slot_context, q as transition_in, r as transition_out, a as space, m as mount_component, u as destroy_component, D as onMount, w as set_data, n as noop } from './chunk.f8a05be3.js';
import { l as loggedIn } from './chunk.628a1ab4.js';

/* src/components/Card.svelte generated by Svelte v3.6.7 */

const file = "src/components/Card.svelte";

function create_fragment(ctx) {
	var div, em, t, current;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c: function create() {
			div = element("div");

			if (!default_slot) {
				em = element("em");
				t = text("no content was provided");
			}

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			if (!default_slot) {
				em = claim_element(div_nodes, "EM", {}, false);
				var em_nodes = children(em);

				t = claim_text(em_nodes, "no content was provided");
				em_nodes.forEach(detach);
			}

			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			if (!default_slot) {
				add_location(em, file, 46, 2, 967);
			}

			attr(div, "class", "card svelte-1m4doad");
			add_location(div, file, 44, 0, 938);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);

			if (!default_slot) {
				append(div, em);
				append(em, t);
			}

			else {
				default_slot.m(div, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return { $$slots, $$scope };
}

class Card extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, []);
	}
}

/* src/Use cases/DisplayHome/DisplayHome.svelte generated by Svelte v3.6.7 */

const file$1 = "src/Use cases/DisplayHome/DisplayHome.svelte";

// (65:0) <Card>
function create_default_slot_2(ctx) {
	var h3, t0, span, t1;

	return {
		c: function create() {
			h3 = element("h3");
			t0 = text("Welcome ");
			span = element("span");
			t1 = text(ctx.userName);
			this.h();
		},

		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", { class: true }, false);
			var h3_nodes = children(h3);

			t0 = claim_text(h3_nodes, "Welcome ");

			span = claim_element(h3_nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t1 = claim_text(span_nodes, ctx.userName);
			span_nodes.forEach(detach);
			h3_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(span, "class", "svelte-163kza3");
			add_location(span, file$1, 65, 13, 1106);
			attr(h3, "class", "svelte-163kza3");
			add_location(h3, file$1, 65, 1, 1094);
		},

		m: function mount(target, anchor) {
			insert(target, h3, anchor);
			append(h3, t0);
			append(h3, span);
			append(span, t1);
		},

		p: function update(changed, ctx) {
			if (changed.userName) {
				set_data(t1, ctx.userName);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(h3);
			}
		}
	};
}

// (69:0) <Card>
function create_default_slot_1(ctx) {
	var h3, t;

	return {
		c: function create() {
			h3 = element("h3");
			t = text("This is a card component");
			this.h();
		},

		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", { class: true }, false);
			var h3_nodes = children(h3);

			t = claim_text(h3_nodes, "This is a card component");
			h3_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(h3, "class", "svelte-163kza3");
			add_location(h3, file$1, 69, 1, 1152);
		},

		m: function mount(target, anchor) {
			insert(target, h3, anchor);
			append(h3, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(h3);
			}
		}
	};
}

// (73:0) <Card>
function create_default_slot(ctx) {
	var h3, t;

	return {
		c: function create() {
			h3 = element("h3");
			t = text("This is a card component");
			this.h();
		},

		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", { class: true }, false);
			var h3_nodes = children(h3);

			t = claim_text(h3_nodes, "This is a card component");
			h3_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(h3, "class", "svelte-163kza3");
			add_location(h3, file$1, 73, 1, 1203);
		},

		m: function mount(target, anchor) {
			insert(target, h3, anchor);
			append(h3, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(h3);
			}
		}
	};
}

function create_fragment$1(ctx) {
	var t0, t1, t2, current;

	var card0 = new Card({
		props: {
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var card1 = new Card({
		props: {
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var card2 = new Card({
		props: {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			t0 = space();
			card0.$$.fragment.c();
			t1 = space();
			card1.$$.fragment.c();
			t2 = space();
			card2.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			t0 = claim_text(nodes, "\n\n\n");
			card0.$$.fragment.l(nodes);
			t1 = claim_text(nodes, "\n\n");
			card1.$$.fragment.l(nodes);
			t2 = claim_text(nodes, "\n\n");
			card2.$$.fragment.l(nodes);
			this.h();
		},

		h: function hydrate() {
			document.title = "Solid on svelte";
		},

		m: function mount(target, anchor) {
			insert(target, t0, anchor);
			mount_component(card0, target, anchor);
			insert(target, t1, anchor);
			mount_component(card1, target, anchor);
			insert(target, t2, anchor);
			mount_component(card2, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var card0_changes = {};
			if (changed.$$scope || changed.userName) card0_changes.$$scope = { changed, ctx };
			card0.$set(card0_changes);

			var card1_changes = {};
			if (changed.$$scope) card1_changes.$$scope = { changed, ctx };
			card1.$set(card1_changes);

			var card2_changes = {};
			if (changed.$$scope) card2_changes.$$scope = { changed, ctx };
			card2.$set(card2_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(card0.$$.fragment, local);

			transition_in(card1.$$.fragment, local);

			transition_in(card2.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(card0.$$.fragment, local);
			transition_out(card1.$$.fragment, local);
			transition_out(card2.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(t0);
			}

			destroy_component(card0, detaching);

			if (detaching) {
				detach(t1);
			}

			destroy_component(card1, detaching);

			if (detaching) {
				detach(t2);
			}

			destroy_component(card2, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	
	
	let userID;
	let userName = "";
	
	onMount(async () => {
		const auth = window.solid.auth;
		auth.trackSession(session => {
			if (!session) {
				console.log('The user is not logged in');
				loggedIn.update(n => false);
				window.location = "/login";
			}
			else {
				console.log(`The user is ${session.webId}`);
				loggedIn.update(n => true);
				userID = session.webId;
				userInfo(userID);
			}
		});
	});

	const userInfo = async (userID) => {
		const data = solid.data;
		const user = data[userID];
		const name = await user.name;
		$$invalidate('userName', userName = name.value);
		console.log("user name", userName);
	};

	return { userName };
}

class DisplayHome extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, []);
	}
}

/* src/routes/index.svelte generated by Svelte v3.6.7 */

function create_fragment$2(ctx) {
	var t, current;

	var displayhome = new DisplayHome({ $$inline: true });

	return {
		c: function create() {
			t = space();
			displayhome.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "\n\n\n");
			displayhome.$$.fragment.l(nodes);
			this.h();
		},

		h: function hydrate() {
			document.title = "Svelte Solid login";
		},

		m: function mount(target, anchor) {
			insert(target, t, anchor);
			mount_component(displayhome, target, anchor);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			transition_in(displayhome.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(displayhome.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(t);
			}

			destroy_component(displayhome, detaching);
		}
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$2, safe_not_equal, []);
	}
}

export default Index;
